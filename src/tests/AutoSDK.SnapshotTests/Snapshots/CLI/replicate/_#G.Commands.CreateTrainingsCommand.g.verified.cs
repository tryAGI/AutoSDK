//HintName: G.Commands.CreateTrainingsCommand.g.cs

#nullable enable

namespace G
{
    internal sealed partial class CreateTrainingsCommand : global::System.CommandLine.Command
    {
        private readonly G.IApi _client;
        private readonly global::System.IServiceProvider _serviceProvider;

        partial void Initialize();
        partial void Validate(
            global::System.CommandLine.ParseResult parseResult,
            string modelOwner,
            string modelName,
            string versionId,
            string destination,
            object input,
            string? webhook,
            global::System.Collections.Generic.IList<global::G.TrainingRequestWebhookEventsFilterItem>? webhookEventsFilter,
            global::System.Threading.CancellationToken cancellationToken);
        partial void Complete(
            global::System.CommandLine.ParseResult parseResult,
            global::System.Threading.CancellationToken cancellationToken);

        private global::System.CommandLine.Argument<string> ModelOwner { get; } = new(
            name: "modelOwner")
        {
            Description = @"The name of the user or organization that owns the model.",
        };

        private global::System.CommandLine.Argument<string> ModelName { get; } = new(
            name: "modelName")
        {
            Description = @"The name of the model.",
        };

        private global::System.CommandLine.Argument<string> VersionId { get; } = new(
            name: "versionId")
        {
            Description = @"The ID of the version.",
        };

        private global::System.CommandLine.Argument<string> Destination { get; } = new(
            name: "destination")
        {
            Description = @"A string representing the desired model to push to in the format `{destination_model_owner}/{destination_model_name}`. This should be an existing model owned by the user or organization making the API request. If the destination is invalid, the server will return an appropriate 4XX response.",
        };

        private global::System.CommandLine.Argument<object> Input { get; } = new(
            name: "input")
        {
            Description = @"An object containing inputs to the Cog model's `train()` function.",
        };

        private global::System.CommandLine.Option<string?> Webhook { get; } = new(
            name: "webhook")
        {
            Description = @"An HTTPS URL for receiving a webhook when the training completes. The webhook will be a POST request where the request body is the same as the response body of the [get training](#trainings.get) operation. If there are network problems, we will retry the webhook a few times, so make sure it can be safely called more than once. Replicate will not follow redirects when sending webhook requests to your service, so be sure to specify a URL that will resolve without redirecting.",
        };

        private global::System.CommandLine.Option<global::System.Collections.Generic.IList<global::G.TrainingRequestWebhookEventsFilterItem>?> WebhookEventsFilter { get; } = new(
            name: "webhookEventsFilter")
        {
            Description = @"By default, we will send requests to your webhook URL whenever there are new outputs or the training has finished. You can change which events trigger webhook requests by specifying `webhook_events_filter` in the training request:

- `start`: immediately on training start
- `output`: each time a training generates an output (note that trainings can generate multiple outputs)
- `logs`: each time log output is generated by a training
- `completed`: when the training reaches a terminal state (succeeded/canceled/failed)

For example, if you only wanted requests to be sent at the start and end of the training, you would provide:

```json
{
  ""destination"": ""my-organization/my-model"",
  ""input"": {
    ""text"": ""Alice""
  },
  ""webhook"": ""https://example.com/my-webhook"",
  ""webhook_events_filter"": [""start"", ""completed""]
}
```

Requests for event types `output` and `logs` will be sent at most once every 500ms. If you request `start` and `completed` webhooks, then they'll always be sent regardless of throttling.",
        };
        public CreateTrainingsCommand(
            G.IApi client,
            global::System.IServiceProvider serviceProvider) : base(
            name: "create",
            description: @"Start a new training of the model version you specify.

Example request body:

```json
{
  ""destination"": ""{new_owner}/{new_name}"",
  ""input"": {
    ""train_data"": ""https://example.com/my-input-images.zip"",
  },
  ""webhook"": ""https://example.com/my-webhook"",
}
```

Example cURL request:

```console
curl -s -X POST \
  -d '{""destination"": ""{new_owner}/{new_name}"", ""input"": {""input_images"": ""https://example.com/my-input-images.zip""}}' \
  -H ""Authorization: Bearer $REPLICATE_API_TOKEN"" \
  -H 'Content-Type: application/json' \
  https://api.replicate.com/v1/models/stability-ai/sdxl/versions/da77bc59ee60423279fd632efb4795ab731d9e3ca9705ef3341091fb989b7eaf/trainings
```

The response will be the training object:

```json
{
  ""id"": ""zz4ibbonubfz7carwiefibzgga"",
  ""model"": ""stability-ai/sdxl"",
  ""version"": ""da77bc59ee60423279fd632efb4795ab731d9e3ca9705ef3341091fb989b7eaf"",
  ""input"": {
    ""input_images"": ""https://example.com/my-input-images.zip""
  },
  ""logs"": """",
  ""error"": null,
  ""status"": ""starting"",
  ""created_at"": ""2023-09-08T16:32:56.990893084Z"",
  ""urls"": {
    ""cancel"": ""https://api.replicate.com/v1/predictions/zz4ibbonubfz7carwiefibzgga/cancel"",
    ""get"": ""https://api.replicate.com/v1/predictions/zz4ibbonubfz7carwiefibzgga""
  }
}
```

As models can take several minutes or more to train, the result will not be available immediately. To get the final result of the training you should either provide a `webhook` HTTPS URL for us to call when the results are ready, or poll the [get a training](#trainings.get) endpoint until it has finished.

When a training completes, it creates a new [version](https://replicate.com/docs/how-does-replicate-work#terminology) of the model at the specified destination.

To find some models to train on, check out the [trainable language models collection](https://replicate.com/collections/trainable-language-models).")
        {
            _client = client;
            _serviceProvider = serviceProvider;

            Arguments.Add(ModelOwner);
            Arguments.Add(ModelName);
            Arguments.Add(VersionId);
            Arguments.Add(Destination);
            Arguments.Add(Input);
            Options.Add(Webhook);
            Options.Add(WebhookEventsFilter);

            Initialize();

            SetAction(HandleAsync);
        }

        private async global::System.Threading.Tasks.Task HandleAsync(
            global::System.CommandLine.ParseResult parseResult,
            global::System.Threading.CancellationToken cancellationToken = default)
        {
            var modelOwner = parseResult.GetRequiredValue(ModelOwner);
            var modelName = parseResult.GetRequiredValue(ModelName);
            var versionId = parseResult.GetRequiredValue(VersionId);
            var destination = parseResult.GetRequiredValue(Destination);
            var input = parseResult.GetRequiredValue(Input);
            var webhook = parseResult.GetRequiredValue(Webhook);
            var webhookEventsFilter = parseResult.GetRequiredValue(WebhookEventsFilter);

            Validate(
                parseResult: parseResult,
                modelOwner: modelOwner,
                modelName: modelName,
                versionId: versionId,
                destination: destination,
                input: input,
                webhook: webhook,
                webhookEventsFilter: webhookEventsFilter,
                cancellationToken: cancellationToken);

            // ReSharper disable once RedundantAssignment
            await _client.CreateTrainingsAsync(
                modelOwner: modelOwner,
                modelName: modelName,
                versionId: versionId,
                destination: destination,
                input: input,
                webhook: webhook,
                webhookEventsFilter: webhookEventsFilter,
                cancellationToken: cancellationToken);

            Complete(
                parseResult: parseResult,
                cancellationToken: cancellationToken);
        }
    }
}